// Generated by dts-bundle v0.4.3
// Dependencies for this module:
//   ../streamline-runtime
//   ../stream

declare module 'ez-streams' {
    import * as DevArray from 'ez-streams/devices/array';
    import * as DevBuffer from 'ez-streams/devices/buffer';
    import * as DevConsole from 'ez-streams/devices/console';
    import * as DevGeneric from 'ez-streams/devices/generic';
    import * as DevQueue from 'ez-streams/devices/queue';
    import * as DevString from 'ez-streams/devices/string';
    export const devices: {
        array: typeof DevArray;
        buffer: typeof DevBuffer;
        child_process: any;
        console: typeof DevConsole;
        file: any;
        generic: typeof DevGeneric;
        http: any;
        net: any;
        node: any;
        queue: typeof DevQueue;
        std: any;
        string: typeof DevString;
        uturn: any;
    };
    import * as HelpBinary from 'ez-streams/helpers/binary';
    export const helpers: {
        binary: typeof HelpBinary;
    };
    export const mappers: {
        convert: any;
        json: any;
    };
    import * as TransCsv from 'ez-streams/transforms/csv';
    import * as TransCut from 'ez-streams/transforms/cut';
    import * as TransJson from 'ez-streams/transforms/json';
    import * as TransLines from 'ez-streams/transforms/lines';
    import * as TransMultipart from 'ez-streams/transforms/multipart';
    import * as TransXml from 'ez-streams/transforms/xml';
    export const transforms: {
        csv: typeof TransCsv;
        cut: typeof TransCut;
        json: typeof TransJson;
        lines: typeof TransLines;
        multipart: typeof TransMultipart;
        xml: typeof TransXml;
    };
    import * as EzPredicate from 'ez-streams/predicate';
    import * as EzReader from 'ez-streams/reader';
    import * as EzWriter from 'ez-streams/writer';
    export const predicate: typeof EzPredicate;
    export const reader: typeof EzReader;
    export const writer: typeof EzWriter;
}

declare module 'ez-streams/devices/array' {
    import { Reader } from 'ez-streams/reader';
    import { Writer } from 'ez-streams/writer';
    export interface Options {
        sync?: boolean;
    }
    export class ArrayWriter<T> extends Writer<T> {
        values: T[];
        constructor(options: Options);
        toArray(): T[];
        result: T[];
    }
    export function reader<T>(array: T[], options?: Options): Reader<T>;
    export function writer<T>(options?: Options): ArrayWriter<{}>;
}

declare module 'ez-streams/devices/buffer' {
    import { Reader } from 'ez-streams/reader';
    import { Writer } from 'ez-streams/writer';
    export interface Options {
        sync?: boolean;
        chunkSize?: number | (() => number);
    }
    export class BufferWriter extends Writer<Buffer> {
        chunks: Buffer[];
        constructor(options: Options);
        toBuffer(): Buffer;
        result: Buffer;
    }
    export function reader(buffer: Buffer, options?: Options | number): Reader<Buffer>;
    export function writer(options?: Options): BufferWriter;
}

declare module 'ez-streams/devices/console' {
    import { Writer } from "ez-streams/writer";
    export const log: Writer<string>;
    export const info: Writer<string>;
    export const warn: Writer<string>;
    export const error: Writer<string>;
}

declare module 'ez-streams/devices/generic' {
    import { _ } from 'streamline-runtime';
    import { Reader } from 'ez-streams/reader';
    import { Writer } from 'ez-streams/writer';
    export const empty: {
        reader: Reader<void>;
        writer: Writer<{}>;
    };
    export function reader<T>(read: (_: _) => T, stop?: (_: _, arg?: any) => void): Reader<T>;
    export function writer<T>(write: (_: _, value: T) => Writer<T>, stop?: (_: _, arg?: any) => Writer<T>): Writer<T>;
}

declare module 'ez-streams/devices/queue' {
    import { Reader } from 'ez-streams/reader';
    import { Writer } from 'ez-streams/writer';
    export interface Duplex<T> {
        reader: Reader<T>;
        writer: Writer<T>;
    }
    export default function <T>(max?: number): Streamline.Queue<T> & Duplex<T>;
}

declare module 'ez-streams/devices/string' {
    import { Reader } from 'ez-streams/reader';
    import { Writer } from 'ez-streams/writer';
    export interface Options {
        sync?: boolean;
        chunkSize?: number | (() => number);
    }
    export class StringWriter extends Writer<string> {
        buf: string;
        constructor(options: Options);
        toString(): string;
        result: string;
    }
    export function reader(text: string, options?: Options | number): Reader<string>;
    export function writer(options?: Options): StringWriter;
    export function factory(url: string): {
        reader: (_: Streamline._) => any;
        writer: (_: Streamline._) => any;
    };
}

declare module 'ez-streams/helpers/binary' {
    import { _ } from "streamline-runtime";
    import { Reader as BaseReader } from "ez-streams/reader";
    import { Writer as BaseWriter } from "ez-streams/writer";
    export interface ReaderOptions {
        endian?: 'big' | 'little';
    }
    export class Reader extends BaseReader<Buffer> {
        reader: BaseReader<Buffer>;
        options: ReaderOptions;
        pos: number;
        buf: Buffer;
        constructor(reader: BaseReader<Buffer>, options: ReaderOptions);
        readData(_: _, len?: number, peekOnly?: boolean): Buffer;
        ensure(_: _, len: number): number;
        peek(_: _, len: number): Buffer;
        unread(len: number): void;
    }
    export interface WriterOptions {
        endian?: 'big' | 'little';
        bufSize?: number;
    }
    export class Writer extends BaseWriter<Buffer> {
        writer: BaseWriter<Buffer>;
        options: WriterOptions;
        pos: number;
        buf: Buffer;
        constructor(writer: BaseWriter<Buffer>, options?: WriterOptions);
        flush(_: _): void;
        ensure(_: _, len: number): void;
        writeDate(_: _, buf: Buffer): void;
    }
    export function reader(reader: BaseReader<Buffer>, options?: ReaderOptions): Reader;
    export function writer(writer: BaseWriter<Buffer>, options?: WriterOptions): Writer;
}

declare module 'ez-streams/transforms/csv' {
    import { Reader } from "ez-streams/reader";
    import { Writer } from "ez-streams/writer";
    export interface ParserOptions {
        sep?: string;
        encoding?: string;
    }
    export function parser(options?: ParserOptions): (_: Streamline._, reader: Reader<string | Buffer>, writer: Writer<any>) => void;
    export interface FormatterOptions {
        sep?: string;
        eol?: string;
    }
    export function formatter(options?: FormatterOptions): (_: Streamline._, reader: Reader<any>, writer: Writer<string>) => void;
}

declare module 'ez-streams/transforms/cut' {
    import { Reader } from "ez-streams/reader";
    import { Writer } from "ez-streams/writer";
    export interface Options {
        size?: number;
    }
    export default function <T>(options?: Options): (_: Streamline._, reader: Reader<T>, writer: Writer<T>) => any;
}

declare module 'ez-streams/transforms/json' {
    import { Reader } from "ez-streams/reader";
    import { Writer } from "ez-streams/writer";
    export interface ParserOptions {
        size?: number;
        encoding?: string;
        reviver?: (key: any, value: any) => any;
        unbounded?: boolean;
    }
    export function parser(options: ParserOptions): (_: Streamline._, reader: Reader<string | Buffer>, writer: Writer<any>) => void;
    export interface FormatterOptions {
        unbounded?: boolean;
        replacer?: (key: string, value: any) => any;
        space?: string;
    }
    export function formatter(options: FormatterOptions): (_: Streamline._, reader: Reader<any>, writer: Writer<string>) => void;
}

declare module 'ez-streams/transforms/lines' {
    import { _ } from "streamline-runtime";
    import { Reader } from "ez-streams/reader";
    import { Writer } from "ez-streams/writer";
    export interface ParserOptions {
        sep?: string;
        encoding?: string;
    }
    export function parser(options?: ParserOptions): (_: _, reader: Reader<string | Buffer>, writer: Writer<string>) => void;
    export interface FormatterOptions {
        eol?: string;
        extra?: boolean;
    }
    export function formatter(options: FormatterOptions): (_: Streamline._, reader: Reader<string>, writer: Writer<string>) => void;
}

declare module 'ez-streams/transforms/multipart' {
    import { Reader } from "ez-streams/reader";
    import { Writer } from "ez-streams/writer";
    export type ParserOptions = {
        [name: string]: string;
    };
    export function parser(options: ParserOptions): (_: Streamline._, reader: Reader<Buffer>, writer: Writer<any>) => void;
    export interface FormatterOptions {
        [name: string]: string;
    }
    export function formatter(options?: FormatterOptions): (_: Streamline._, reader: Reader<Reader<string>>, writer: Writer<Buffer>) => void;
}

declare module 'ez-streams/transforms/xml' {
    import { Reader } from "ez-streams/reader";
    import { Writer } from "ez-streams/writer";
    export interface ParserOptions {
        tags?: string;
        encoding?: string;
    }
    export function parser(options?: ParserOptions): (_: Streamline._, reader: Reader<string | Buffer>, writer: Writer<any>) => void;
    export interface FormatterOptions {
        tags?: string;
        indent?: string;
    }
    export interface Builder {
        beginTag: (tag: string) => void;
        addAttribute: (atb: string, val: any) => void;
        endTag: (close?: boolean) => void;
        closeTag: (tag: string, val?: any) => void;
        cdata: (data: string) => void;
        getResult: (extraIndent?: boolean) => string;
    }
    export function formatter(options?: FormatterOptions): (_: Streamline._, reader: Reader<any>, writer: Writer<string>) => void;
}

declare module 'ez-streams/predicate' {
    import { _ } from "streamline-runtime";
    export interface Options {
        allowEval?: boolean;
    }
    export type Predicate = (_: _, val: any) => boolean;
    export type Op = (val: any, parent?: any) => Predicate;
    export function converter(options?: Options): (val: any) => (_: Streamline._, val: any) => boolean;
    export const convert: (val: any) => (_: Streamline._, val: any) => boolean;
}

declare module 'ez-streams/reader' {
    /**
      * Copyright (c) 2013 Bruno Jouhier <bruno.jouhier@sage.com>
      *
      * Permission is hereby granted, free of charge, to any person
      * obtaining a copy of this software and associated documentation
      * files (the "Software"), to deal in the Software without
      * restriction, including without limitation the rights to use,
      * copy, modify, merge, publish, distribute, sublicense, and/or sell
      * copies of the Software, and to permit persons to whom the
      * Software is furnished to do so, subject to the following
      * conditions:
      *
      * The above copyright notice and this permission notice shall be
      * included in all copies or substantial portions of the Software.
      *
      * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
      * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
      * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
      * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
      * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
      * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
      * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
      * OTHER DEALINGS IN THE SOFTWARE.
      */
    import { _ } from "streamline-runtime";
    import { Writer } from 'ez-streams/writer';
    import * as nodeStream from "stream";
    export interface ParallelOptions {
        count?: number;
        shuffle?: boolean;
    }
    export interface CompareOptions<T> {
        compare?: (v1: T, v2: T) => number;
    }
    export interface Stoppable {
        stop: (_: _, arg?: any) => void;
    }
    export class Reader<T> {
        parent: Stoppable;
        read: (_: _) => T;
        _stop: (_: _, arg?: any) => void;
        stopped: boolean;
        headers: {
            [name: string]: string;
        };
        constructor(read: (_: _) => T, stop?: (_: _, arg: any) => void, parent?: Stoppable);
        forEach(_: _, fn: (_: _, value: T, index: number) => void, thisObj?: any): any;
        map<U>(fn: (_: _, value: T, index: number) => U, thisObj?: any): Reader<U>;
        every(_: _, fn: ((_: _, value: T) => boolean) | {}, thisObj?: any): any;
        some(_: _, fn: ((_: _, value: T) => boolean) | {}, thisObj?: any): any;
        reduce<U>(_: _, fn: (_: _, prev: U, value: T) => U, v: U, thisObj?: any): U;
        pipe(_: _, writer: Writer<T>): any;
        tee(writer: Writer<T>): Reader<T>;
        dup(): [Reader<T>, Reader<T>];
        concat(...readers: (Reader<T> | Reader<T>[])[]): Reader<T>;
        toArray(_: _): T[];
        readAll(_: _): string | Buffer | T[];
        transform<U>(fn: (_: _, reader: Reader<T>, writer: Writer<U>) => void, thisObj?: any): Reader<U>;
        filter(fn: ((_: _, value: T, index: number) => boolean) | {}, thisObj?: any): Reader<T>;
        until(fn: ((_: _, value: T, index: number) => boolean) | {}, thisObj?: any, stopArg?: any): Reader<T>;
        while(fn: ((_: _, value: T, index: number) => boolean) | {}, thisObj?: any, stopArg?: any): Reader<T>;
        limit(n: number, stopArg?: any): Reader<T>;
        skip(n: number): Reader<T>;
        fork(consumers: ((source: any) => Reader<T>)[]): StreamGroup<T>;
        parallel(options: ParallelOptions | number, consumer: (source: any) => Reader<T>): Reader<{}>;
        peekable(): PeekableReader<T>;
        buffer(max: number): Reader<{}>;
        join(streams: Reader<T>[], thisObj?: any): Reader<{}>;
        nodify(): any;
        nodeTransform(duplex: nodeStream.Duplex): any;
        compare(_: _, other: Reader<T>, options: CompareOptions<T>): number;
        stop(_: _, arg?: any): void;
    }
    export class PeekableReader<T> extends Reader<T> {
        buffered: T[];
        constructor(parent: Reader<T>);
        unread(val: T): this;
        peek(_: _): T;
    }
    export function create<T>(read: (_: _) => T, stop?: (_: _, arg: any) => void): Reader<T>;
    export class StreamGroup<T> implements Stoppable {
        readers: Reader<T>[];
        constructor(readers: Reader<T>[]);
        stop(_: _, arg?: any): void;
        dequeue(): Reader<{}>;
        rr(): Reader<T>;
        join(fn: (_: _, values: T[]) => T, thisObj?: any): Reader<{}>;
    }
}

declare module 'ez-streams/writer' {
    /**
      * Copyright (c) 2013 Bruno Jouhier <bruno.jouhier@sage.com>
      *
      * Permission is hereby granted, free of charge, to any person
      * obtaining a copy of this software and associated documentation
      * files (the "Software"), to deal in the Software without
      * restriction, including without limitation the rights to use,
      * copy, modify, merge, publish, distribute, sublicense, and/or sell
      * copies of the Software, and to permit persons to whom the
      * Software is furnished to do so, subject to the following
      * conditions:
      *
      * The above copyright notice and this permission notice shall be
      * included in all copies or substantial portions of the Software.
      *
      * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
      * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
      * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
      * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
      * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
      * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
      * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
      * OTHER DEALINGS IN THE SOFTWARE.
      */
    import { _ } from "streamline-runtime";
    import * as nodeStream from "stream";
    export class Writer<T> {
        write: (_: _, value: T) => Writer<T>;
        ended: boolean;
        constructor(write: (_: _, value: T) => Writer<T>, stop?: (_: _, arg?: any) => Writer<T>);
        writeAll(_: _, val: T): this;
        stop(_: _, arg?: any): Writer<T>;
        end(): this;
        pre: Pre<T>;
        nodify(): nodeStream.Writable;
    }
    export function create<T>(write: (_: _, value: T) => Writer<T>, stop?: (_: _, arg?: any) => Writer<T>): Writer<T>;
    export class Pre<T> {
        writer: Writer<T>;
        constructor(writer: Writer<T>);
    }
}

